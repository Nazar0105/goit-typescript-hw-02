
function getPromise<T extends [string, number]>():Promise <T> {
  return new Promise((resolve) => {
    resolve(['Text', 50] as T);
  });
}

getPromise()
  .then((data) => {
    console.log(data);
  });

// Так дякую вам за підказку тут я випарвив)
// У цій оновленій функції "getPromise", я використав обмеження типу "T extends
// [string, number]"", що означає, що "T" повинен бути кортежем, де перший елемент є
// рядком, а другий - числом. Функція повертає проміс типу "T", а мені необхідно було
// вказати resolve(['Text', 50] as T).


// Отже, коли я викликаю "getPromise()"", "T" автоматично стає типом "[string,
// number]".В цьому випадку масив, що повертається з промісу, дійсно міститиме рядок та число.

// Цей код працює правильно, оскільки він гарантує, що тип даних, що повертається, відповідає обмеженню типу, який я вказав.

